{"ast":null,"code":"export class KillStreakSystem {\n  constructor() {\n    this.currentStreak = 0;\n    this.maxStreak = 0;\n    this.streakTimer = 0;\n    this.streakTimeout = 3000;\n    // 3 seconds to maintain streak\n    this.lastKillTime = 0;\n    this.streakBonuses = {\n      5: {\n        name: 'Killing Spree',\n        multiplier: 1.5\n      },\n      10: {\n        name: 'Rampage',\n        multiplier: 2.0\n      },\n      15: {\n        name: 'Dominating',\n        multiplier: 2.5\n      },\n      20: {\n        name: 'Unstoppable',\n        multiplier: 3.0\n      },\n      25: {\n        name: 'Godlike',\n        multiplier: 4.0\n      }\n    };\n  }\n  addKill() {\n    const currentTime = Date.now();\n\n    // Reset streak if too much time has passed\n    if (currentTime - this.lastKillTime > this.streakTimeout) {\n      this.currentStreak = 0;\n    }\n    this.currentStreak++;\n    this.maxStreak = Math.max(this.maxStreak, this.currentStreak);\n    this.streakTimer = this.streakTimeout;\n    this.lastKillTime = currentTime;\n    const bonus = this.getStreakBonus();\n    const multiplier = bonus ? bonus.multiplier : 1;\n    return {\n      streak: this.currentStreak,\n      bonus: bonus ? bonus.name : undefined,\n      multiplier: multiplier\n    };\n  }\n  updateStreak(deltaTime) {\n    if (this.currentStreak > 0) {\n      this.streakTimer -= deltaTime;\n      if (this.streakTimer <= 0) {\n        this.resetStreak();\n      }\n    }\n  }\n  resetStreak() {\n    this.currentStreak = 0;\n    this.streakTimer = 0;\n  }\n  getStreakBonus() {\n    for (let threshold = 25; threshold >= 5; threshold -= 5) {\n      if (this.currentStreak >= threshold) {\n        return this.streakBonuses[threshold];\n      }\n    }\n    return null;\n  }\n  getStreakMultiplier() {\n    const bonus = this.getStreakBonus();\n    return bonus ? bonus.multiplier : 1;\n  }\n  getCurrentStreak() {\n    return this.currentStreak;\n  }\n  getMaxStreak() {\n    return this.maxStreak;\n  }\n  getStreakTimeRemaining() {\n    return Math.max(0, this.streakTimer);\n  }\n  getStreakProgress() {\n    const nextThreshold = this.getNextThreshold();\n    if (!nextThreshold) return 1;\n    const currentThreshold = Math.floor(this.currentStreak / 5) * 5;\n    const progress = (this.currentStreak - currentThreshold) / 5;\n    return Math.min(1, progress);\n  }\n  getNextThreshold() {\n    for (let threshold = 5; threshold <= 25; threshold += 5) {\n      if (this.currentStreak < threshold) {\n        return threshold;\n      }\n    }\n    return null;\n  }\n  updateGameStats(gameStats) {\n    gameStats.killStreak = this.currentStreak;\n    gameStats.maxKillStreak = this.maxStreak;\n  }\n  drawStreakUI(ctx, canvas) {\n    if (this.currentStreak > 0) {\n      const bonus = this.getStreakBonus();\n      const progress = this.getStreakProgress();\n      const timeRemaining = this.getStreakTimeRemaining();\n\n      // Streak display\n      ctx.fillStyle = '#ff6600';\n      ctx.font = 'bold 20px Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText(`${this.currentStreak} KILL STREAK`, canvas.width / 2, 160);\n      if (bonus) {\n        ctx.fillStyle = '#ff0000';\n        ctx.font = 'bold 24px Arial';\n        ctx.fillText(bonus.name, canvas.width / 2, 190);\n      }\n\n      // Streak progress bar\n      const nextThreshold = this.getNextThreshold();\n      if (nextThreshold) {\n        const barWidth = 200;\n        const barHeight = 8;\n        const barX = canvas.width / 2 - barWidth / 2;\n        const barY = 210;\n\n        // Background\n        ctx.fillStyle = '#333333';\n        ctx.fillRect(barX, barY, barWidth, barHeight);\n\n        // Progress fill\n        ctx.fillStyle = '#ff6600';\n        ctx.fillRect(barX, barY, barWidth * progress, barHeight);\n\n        // Next threshold indicator\n        ctx.fillStyle = '#ffffff';\n        ctx.font = '14px Arial';\n        ctx.fillText(`Next: ${nextThreshold}`, canvas.width / 2, barY + 25);\n      }\n\n      // Time remaining indicator\n      ctx.fillStyle = '#ffff00';\n      ctx.font = '16px Arial';\n      ctx.fillText(`${Math.ceil(timeRemaining / 1000)}s`, canvas.width / 2, 240);\n      ctx.textAlign = 'left';\n    }\n  }\n}","map":{"version":3,"names":["KillStreakSystem","constructor","currentStreak","maxStreak","streakTimer","streakTimeout","lastKillTime","streakBonuses","name","multiplier","addKill","currentTime","Date","now","Math","max","bonus","getStreakBonus","streak","undefined","updateStreak","deltaTime","resetStreak","threshold","getStreakMultiplier","getCurrentStreak","getMaxStreak","getStreakTimeRemaining","getStreakProgress","nextThreshold","getNextThreshold","currentThreshold","floor","progress","min","updateGameStats","gameStats","killStreak","maxKillStreak","drawStreakUI","ctx","canvas","timeRemaining","fillStyle","font","textAlign","fillText","width","barWidth","barHeight","barX","barY","fillRect","ceil"],"sources":["/Users/ronellbradley/Desktop/Kaden & Adelynn Space Adventures/src/systems/KillStreakSystem.ts"],"sourcesContent":["import { GameStats } from '../types/GameTypes';\n\nexport class KillStreakSystem {\n  private currentStreak: number = 0;\n  private maxStreak: number = 0;\n  private streakTimer: number = 0;\n  private streakTimeout: number = 3000; // 3 seconds to maintain streak\n  private lastKillTime: number = 0;\n  private streakBonuses: { [key: number]: { name: string; multiplier: number } } = {\n    5: { name: 'Killing Spree', multiplier: 1.5 },\n    10: { name: 'Rampage', multiplier: 2.0 },\n    15: { name: 'Dominating', multiplier: 2.5 },\n    20: { name: 'Unstoppable', multiplier: 3.0 },\n    25: { name: 'Godlike', multiplier: 4.0 }\n  };\n\n  addKill(): { streak: number; bonus?: string; multiplier: number } {\n    const currentTime = Date.now();\n    \n    // Reset streak if too much time has passed\n    if (currentTime - this.lastKillTime > this.streakTimeout) {\n      this.currentStreak = 0;\n    }\n    \n    this.currentStreak++;\n    this.maxStreak = Math.max(this.maxStreak, this.currentStreak);\n    this.streakTimer = this.streakTimeout;\n    this.lastKillTime = currentTime;\n    \n    const bonus = this.getStreakBonus();\n    const multiplier = bonus ? bonus.multiplier : 1;\n    \n    return {\n      streak: this.currentStreak,\n      bonus: bonus ? bonus.name : undefined,\n      multiplier: multiplier\n    };\n  }\n\n  updateStreak(deltaTime: number): void {\n    if (this.currentStreak > 0) {\n      this.streakTimer -= deltaTime;\n      \n      if (this.streakTimer <= 0) {\n        this.resetStreak();\n      }\n    }\n  }\n\n  resetStreak(): void {\n    this.currentStreak = 0;\n    this.streakTimer = 0;\n  }\n\n  getStreakBonus(): { name: string; multiplier: number } | null {\n    for (let threshold = 25; threshold >= 5; threshold -= 5) {\n      if (this.currentStreak >= threshold) {\n        return this.streakBonuses[threshold];\n      }\n    }\n    return null;\n  }\n\n  getStreakMultiplier(): number {\n    const bonus = this.getStreakBonus();\n    return bonus ? bonus.multiplier : 1;\n  }\n\n  getCurrentStreak(): number {\n    return this.currentStreak;\n  }\n\n  getMaxStreak(): number {\n    return this.maxStreak;\n  }\n\n  getStreakTimeRemaining(): number {\n    return Math.max(0, this.streakTimer);\n  }\n\n  getStreakProgress(): number {\n    const nextThreshold = this.getNextThreshold();\n    if (!nextThreshold) return 1;\n    \n    const currentThreshold = Math.floor(this.currentStreak / 5) * 5;\n    const progress = (this.currentStreak - currentThreshold) / 5;\n    return Math.min(1, progress);\n  }\n\n  getNextThreshold(): number | null {\n    for (let threshold = 5; threshold <= 25; threshold += 5) {\n      if (this.currentStreak < threshold) {\n        return threshold;\n      }\n    }\n    return null;\n  }\n\n  updateGameStats(gameStats: GameStats): void {\n    gameStats.killStreak = this.currentStreak;\n    gameStats.maxKillStreak = this.maxStreak;\n  }\n\n  drawStreakUI(ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement): void {\n    if (this.currentStreak > 0) {\n      const bonus = this.getStreakBonus();\n      const progress = this.getStreakProgress();\n      const timeRemaining = this.getStreakTimeRemaining();\n      \n      // Streak display\n      ctx.fillStyle = '#ff6600';\n      ctx.font = 'bold 20px Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText(\n        `${this.currentStreak} KILL STREAK`,\n        canvas.width / 2,\n        160\n      );\n      \n      if (bonus) {\n        ctx.fillStyle = '#ff0000';\n        ctx.font = 'bold 24px Arial';\n        ctx.fillText(\n          bonus.name,\n          canvas.width / 2,\n          190\n        );\n      }\n      \n      // Streak progress bar\n      const nextThreshold = this.getNextThreshold();\n      if (nextThreshold) {\n        const barWidth = 200;\n        const barHeight = 8;\n        const barX = canvas.width / 2 - barWidth / 2;\n        const barY = 210;\n        \n        // Background\n        ctx.fillStyle = '#333333';\n        ctx.fillRect(barX, barY, barWidth, barHeight);\n        \n        // Progress fill\n        ctx.fillStyle = '#ff6600';\n        ctx.fillRect(barX, barY, barWidth * progress, barHeight);\n        \n        // Next threshold indicator\n        ctx.fillStyle = '#ffffff';\n        ctx.font = '14px Arial';\n        ctx.fillText(\n          `Next: ${nextThreshold}`,\n          canvas.width / 2,\n          barY + 25\n        );\n      }\n      \n      // Time remaining indicator\n      ctx.fillStyle = '#ffff00';\n      ctx.font = '16px Arial';\n      ctx.fillText(\n        `${Math.ceil(timeRemaining / 1000)}s`,\n        canvas.width / 2,\n        240\n      );\n      \n      ctx.textAlign = 'left';\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}