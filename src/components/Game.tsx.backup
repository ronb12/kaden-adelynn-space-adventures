import React, { useState, useEffect, useRef, useCallback } from 'react';
import './Game.css';

// Import all the new systems
import { PowerUpSystem } from '../systems/PowerUpSystem';
import { WingFighterSystem } from '../systems/WingFighterSystem';
import { ShieldSystem } from '../systems/ShieldSystem';
import { ComboSystem } from '../systems/ComboSystem';
import { KillStreakSystem } from '../systems/KillStreakSystem';
import { EnhancedBossSystem } from '../systems/EnhancedBossSystem';
import { EnhancedEnemySystem } from '../systems/EnhancedEnemySystem';
import { EnhancedAchievementSystem } from '../systems/EnhancedAchievementSystem';
import { AudioSystem } from '../systems/AudioSystem';
import { DifficultySystem } from '../systems/DifficultySystem';
import { MobileSystem } from '../systems/MobileSystem';
import ResponsiveSystem from '../systems/ResponsiveSystem';

// Import new features
import { Storyline } from '../story/Storyline';
import { ShipRenderer } from '../graphics/ShipDesigns';
import { KadenSpriteRenderer } from '../graphics/KadenSprite';
import { AdelynnSpriteRenderer } from '../graphics/AdelynnSprite';
import SettingsPanel from './SettingsPanel';
import CharacterSelection from './CharacterSelection';
import PWAInstallPrompt from './PWAInstallPrompt';

// Import types
import { Player, Enemy, Bullet, PowerUp, Boss, GameStats, GameState } from '../types/GameTypes';

const Game: React.FC = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const gameLoopRef = useRef<number | null>(null);
  const lastTimeRef = useRef<number>(0);
  
  // Game state
  const [gameState, setGameState] = useState<GameState>('menu');
  const [selectedCharacter, setSelectedCharacter] = useState<string>('kaden');
  const [showSettings, setShowSettings] = useState(false);
  const [showCharacterSelection, setShowCharacterSelection] = useState(false);
  const [currentStoryEvent, setCurrentStoryEvent] = useState<string>('');
  
  // Game objects
  const playerRef = useRef<Player>({
    x: 0,
    y: 0,
    width: 50,
    height: 60,
    speed: 5,
    maxSpeed: 8,
    health: 100,
    maxHealth: 100,
    invulnerable: false,
    invulnerabilityTime: 0,
    level: 1,
    xp: 0,
    maxXP: 100,
    hasShield: false,
    shieldTime: 0,
    rapidFire: false,
    rapidFireTime: 0,
    doubleShot: false,
    wingFighters: []
  });
  
  const bulletsRef = useRef<Bullet[]>([]);
  const enemiesRef = useRef<Enemy[]>([]);
  const bossesRef = useRef<Boss[]>([]);
  const powerUpsRef = useRef<PowerUp[]>([]);
  const keysRef = useRef<{ [key: string]: boolean }>({});
  const touchRef = useRef({ startX: 0, startY: 0, currentX: 0, currentY: 0 });
  
  // Game stats
  const [gameStats, setGameStats] = useState<GameStats>({
    score: 0,
    highScore: parseInt(localStorage.getItem('highScore') || '0'),
    lives: 3,
    health: 100,
    maxHealth: 100,
    combo: 0,
    killStreak: 0,
    maxCombo: 0,
    maxKillStreak: 0,
    playerLevel: 1,
    playerXP: 0,
    bossesDefeated: 0,
    enemiesDestroyed: 0,
    powerUpsCollected: 0,
    gameTime: 0,
    difficulty: 'medium',
    wingFighters: 0,
    shieldsUsed: 0,
    weaponsUsed: 0,
    livesLost: 0,
    shieldTime: 0,
    rapidFireTime: 0,
    doubleShotTime: 0,
    rapidFireUses: 0,
    doubleShotUses: 0,
    shieldUses: 0,
    speedBoostUses: 0,
    healthBoostUses: 0,
    scoreMultiplierUses: 0
  });

  // System refs
  const powerUpSystemRef = useRef(new PowerUpSystem());
  const wingFighterSystemRef = useRef(new WingFighterSystem());
  const shieldSystemRef = useRef(new ShieldSystem());
  const comboSystemRef = useRef(new ComboSystem());
  const killStreakSystemRef = useRef(new KillStreakSystem());
  const bossSystemRef = useRef(new EnhancedBossSystem());
  const enemySystemRef = useRef(new EnhancedEnemySystem());
  const achievementSystemRef = useRef(new EnhancedAchievementSystem());
  const audioSystemRef = useRef(new AudioSystem());
  const difficultySystemRef = useRef(new DifficultySystem());
  const mobileSystemRef = useRef(new MobileSystem());
  const responsiveSystemRef = useRef(new ResponsiveSystem());

  // Initialize canvas with responsive system
  useEffect(() => {
    const canvas = canvasRef.current;
    if (canvas) {
      // Initialize responsive system
      const responsiveSettings = responsiveSystemRef.current.initialize();
      
      // Update canvas with responsive settings
      responsiveSystemRef.current.updateCanvas(canvas);
      
      // Initialize player position
      playerRef.current.x = canvas.width / 2 - 25;
      playerRef.current.y = canvas.height - 80;
    }
  }, []);

  // Initialize audio system on first user interaction
  useEffect(() => {
    const initAudio = async () => {
      await audioSystemRef.current.initOnUserInteraction();
    };
    
    // Initialize audio on any user interaction
    const handleUserInteraction = () => {
      initAudio();
      document.removeEventListener('click', handleUserInteraction);
      document.removeEventListener('keydown', handleUserInteraction);
      document.removeEventListener('touchstart', handleUserInteraction);
    };
    
    document.addEventListener('click', handleUserInteraction);
    document.addEventListener('keydown', handleUserInteraction);
    document.addEventListener('touchstart', handleUserInteraction);
    
    return () => {
      document.removeEventListener('click', handleUserInteraction);
      document.removeEventListener('keydown', handleUserInteraction);
      document.removeEventListener('touchstart', handleUserInteraction);
    };
  }, []);

  // Keyboard event handlers
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      keysRef.current[event.code] = true;
      
      if (event.code === 'KeyS') {
        event.preventDefault();
        console.log('ğŸ® S key pressed!');
        shoot();
      }
    };

    const handleKeyUp = (event: KeyboardEvent) => {
      keysRef.current[event.code] = false;
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  // Touch event handlers
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const handleTouchStart = (event: TouchEvent) => {
      event.preventDefault();
      const touch = event.touches[0];
      touchRef.current.startX = touch.clientX;
      touchRef.current.startY = touch.clientY;
      touchRef.current.currentX = touch.clientX;
      touchRef.current.currentY = touch.clientY;
    };

    const handleTouchMove = (event: TouchEvent) => {
      event.preventDefault();
      const touch = event.touches[0];
      touchRef.current.currentX = touch.clientX;
      touchRef.current.currentY = touch.clientY;
    };

    const handleTouchEnd = (event: TouchEvent) => {
      event.preventDefault();
      const touch = event.changedTouches[0];
      const canvas = canvasRef.current;
      if (!canvas) return;

      const rect = canvas.getBoundingClientRect();
      const touchX = touch.clientX - rect.left;
      const touchY = touch.clientY - rect.top;

      // Check if touch is on shoot button
      const shootButton = document.querySelector('.touch-shoot-button');
      if (shootButton) {
        const buttonRect = shootButton.getBoundingClientRect();
        if (touchX >= buttonRect.left - rect.left && 
            touchX <= buttonRect.right - rect.left &&
            touchY >= buttonRect.top - rect.top && 
            touchY <= buttonRect.bottom - rect.top) {
          shoot();
          mobileSystemRef.current.lightVibrate();
          return;
        }
      }

      // Handle touch movement for player control
      const deltaX = touchRef.current.currentX - touchRef.current.startX;
      const deltaY = touchRef.current.currentY - touchRef.current.startY;
      
      if (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10) {
        // Move player based on touch movement
        const canvas = canvasRef.current;
        if (canvas) {
          playerRef.current.x = Math.max(0, Math.min(canvas.width - playerRef.current.width, playerRef.current.x + deltaX * 0.5));
          playerRef.current.y = Math.max(0, Math.min(canvas.height - playerRef.current.height, playerRef.current.y + deltaY * 0.5));
        }
      }
    };

    canvas.addEventListener('touchstart', handleTouchStart);
    canvas.addEventListener('touchmove', handleTouchMove);
    canvas.addEventListener('touchend', handleTouchEnd);

    return () => {
      canvas.removeEventListener('touchstart', handleTouchStart);
      canvas.removeEventListener('touchmove', handleTouchMove);
      canvas.removeEventListener('touchend', handleTouchEnd);
    };
  }, []);

  const startGame = useCallback(() => {
    setGameState('playing');
    
    // Reset game stats
    setGameStats(prevStats => ({
      ...prevStats,
      score: 0,
      enemiesDestroyed: 0,
      bossesDefeated: 0,
      combo: 0,
      killStreak: 0,
      gameTime: 0,
      weaponsUsed: 0,
      livesLost: 0
    }));
    
    // Reset player position
    const canvas = canvasRef.current;
    if (canvas) {
      playerRef.current = {
        x: canvas.width / 2 - 25,
        y: canvas.height - 80,
        width: 50,
        height: 60,
        speed: 5,
        maxSpeed: 8,
        health: 100,
        maxHealth: 100,
        invulnerable: false,
        invulnerabilityTime: 0,
        level: 1,
        xp: 0,
        maxXP: 100,
        hasShield: false,
        shieldTime: 0,
        rapidFire: false,
        rapidFireTime: 0,
        doubleShot: false,
        wingFighters: []
      };
    }
    
    // Clear all game objects
    bulletsRef.current = [];
    enemiesRef.current = [];
    bossesRef.current = [];
    powerUpsRef.current = [];
    
    // Reset systems
    comboSystemRef.current = new ComboSystem();
    killStreakSystemRef.current = new KillStreakSystem();
    achievementSystemRef.current = new EnhancedAchievementSystem();
    
    console.log('ğŸ® Game started!');
  }, []);

  // Game loop
  const gameLoop = useCallback(() => {
    if (gameState !== 'playing') return;

    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Clear canvas
    ctx.fillStyle = '#000011';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw starfield background
    ctx.fillStyle = '#ffffff';
    for (let i = 0; i < 100; i++) {
      const x = (i * 37) % canvas.width;
      const y = (i * 23 + Date.now() * 0.1) % canvas.height;
      ctx.fillRect(x, y, 1, 1);
    }

    // Update game time
    setGameStats(prevStats => ({
      ...prevStats,
      gameTime: prevStats.gameTime + 16
    }));

    // Update systems
    comboSystemRef.current.updateCombo(16);
    killStreakSystemRef.current.updateStreak(16);

    // Update player
    updatePlayer();
    
    // Update bullets
    updateBullets();
    
    // Update enemies
    updateEnemies();
    
    // Update bosses
    updateBosses();
    
    // Update power-ups
    updatePowerUps();
    
    // Check collisions
    checkCollisions();
    
    // Draw everything
    drawPlayer(ctx);
    drawBullets(ctx);
    drawEnemies(ctx);
    drawBosses(ctx);
    drawPowerUps(ctx);
    drawUI(ctx);

    // Continue game loop
    requestAnimationFrame(gameLoop);
  }, [gameState]);

  // Start game loop when game starts
  useEffect(() => {
    if (gameState === 'playing') {
      gameLoop();
    }
  }, [gameState, gameLoop]);

  // Update functions
  const updatePlayer = useCallback(() => {
    const player = playerRef.current;
    const keys = keysRef.current;

    // Handle player movement
    if (keys['ArrowLeft'] || keys['KeyA']) {
      player.x = Math.max(0, player.x - player.speed);
    }
    if (keys['ArrowRight'] || keys['KeyD']) {
      const canvas = canvasRef.current;
      if (canvas) {
        player.x = Math.min(canvas.width - player.width, player.x + player.speed);
      }
    }
    if (keys['ArrowUp'] || keys['KeyW']) {
      player.y = Math.max(0, player.y - player.speed);
    }
    if (keys['ArrowDown'] || keys['KeyS']) {
      const canvas = canvasRef.current;
      if (canvas) {
        player.y = Math.min(canvas.height - player.height, player.y + player.speed);
      }
    }

    // Update invulnerability
    if (player.invulnerable) {
      player.invulnerabilityTime--;
      if (player.invulnerabilityTime <= 0) {
        player.invulnerable = false;
      }
    }
  }, []);

  const updateBullets = useCallback(() => {
    const bullets = bulletsRef.current;
    
    if (bullets.length > 0) {
      console.log('ğŸ”« Updating bullets:', bullets.length);
    }
    
    bullets.forEach((bullet, index) => {
      bullet.y += bullet.speed * (bullet.owner === 'player' ? -1 : 1);
      
      // Remove bullets that are off screen
      const canvas = canvasRef.current;
      if (canvas && (bullet.y < 0 || bullet.y > canvas.height)) {
        bullets.splice(index, 1);
        console.log('ğŸ—‘ï¸ Bullet removed, remaining:', bullets.length);
      }
    });
  }, []);

  const updateEnemies = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    // Use enhanced enemy system
    const newEnemy = enemySystemRef.current.spawnEnemy(canvas, gameStats.score);
    if (newEnemy) {
      enemiesRef.current.push(newEnemy);
    }
    
    // Update existing enemies with enhanced AI
    enemiesRef.current.forEach((enemy, index) => {
      enemySystemRef.current.updateEnemyAI(enemy, playerRef.current.x, playerRef.current.y, canvas, 16);
      
      // Remove enemies that are off screen
      if (enemy.y > canvas.height) {
        enemiesRef.current.splice(index, 1);
      }
    });
  }, []);

  const updateBosses = useCallback(() => {
    // Boss spawning logic would go here
    // For now, just update existing bosses
    const bosses = bossesRef.current;
    bosses.forEach((boss, index) => {
      boss.y += boss.speed;
      
      // Remove bosses that are off screen
      const canvas = canvasRef.current;
      if (canvas && boss.y > canvas.height) {
        bosses.splice(index, 1);
      }
    });
  }, []);

  const updatePowerUps = useCallback(() => {
    const powerUps = powerUpsRef.current;
    
    powerUps.forEach((powerUp, index) => {
      powerUp.y += 2; // Fixed speed for power-ups
      
      // Remove power-ups that are off screen
      const canvas = canvasRef.current;
      if (canvas && powerUp.y > canvas.height) {
        powerUps.splice(index, 1);
      }
    });
  }, []);

  const checkCollisions = useCallback(() => {
    const player = playerRef.current;
    const bullets = bulletsRef.current;
    const enemies = enemiesRef.current;
    const powerUps = powerUpsRef.current;

    // Player vs Enemies
    enemies.forEach((enemy, enemyIndex) => {
      if (player.x < enemy.x + enemy.width &&
          player.x + player.width > enemy.x &&
          player.y < enemy.y + enemy.height &&
          player.y + player.height > enemy.y) {
        
        // Player takes damage
        takeDamage(20);
        enemies.splice(enemyIndex, 1);
      }
    });

    // Bullets vs Enemies
    bullets.forEach((bullet, bulletIndex) => {
      if (bullet.owner === 'player') {
        enemies.forEach((enemy, enemyIndex) => {
          if (bullet.x < enemy.x + enemy.width &&
              bullet.x + bullet.width > enemy.x &&
              bullet.y < enemy.y + enemy.height &&
              bullet.y + bullet.height > enemy.y) {
            
            // Enemy takes damage
            enemy.health--;
            bullets.splice(bulletIndex, 1);
            
            if (enemy.health <= 0) {
              // Enemy destroyed - use combo system
              enemies.splice(enemyIndex, 1);
              const comboMultiplier = comboSystemRef.current.addKill();
              const baseScore = 100;
              const finalScore = baseScore * comboMultiplier;
              
              setGameStats(prevStats => ({
                ...prevStats,
                score: prevStats.score + finalScore,
                enemiesDestroyed: prevStats.enemiesDestroyed + 1
              }));
            }
          }
        });
      }
    });

    // Player vs Power-ups
    powerUps.forEach((powerUp, powerUpIndex) => {
      if (player.x < powerUp.x + powerUp.width &&
          player.x + player.width > powerUp.x &&
          player.y < powerUp.y + powerUp.height &&
          player.y + player.height > powerUp.y) {
        
        // Collect power-up
        powerUps.splice(powerUpIndex, 1);
        // Power-up effects would be applied here
        setGameStats(prevStats => ({
          ...prevStats,
          score: prevStats.score + 50
        }));
      }
    });
  }, []);

  const takeDamage = useCallback((damage: number) => {
    const player = playerRef.current;
    
    if (player.invulnerable) return;
    
    player.health -= damage;
    player.invulnerable = true;
    player.invulnerabilityTime = 60; // 1 second at 60fps
    
    if (player.health <= 0) {
      setGameState('gameOver');
      setGameStats(prevStats => ({
        ...prevStats,
        livesLost: prevStats.livesLost + 1
      }));
    }
  }, []);

  // Draw functions
  const drawPlayer = useCallback((ctx: CanvasRenderingContext2D) => {
    const player = playerRef.current;
    
    if (player.invulnerable) {
      ctx.globalAlpha = 0.5;
    }

    // Draw enhanced player ship using ShipRenderer
    if (selectedCharacter === 'kaden') {
      ShipRenderer.drawKadenShip(ctx, player.x, player.y, player.width, player.height, 0);
    } else if (selectedCharacter === 'adelynn') {
      ShipRenderer.drawAdelynnShip(ctx, player.x, player.y, player.width, player.height, 0);
    }

    ctx.globalAlpha = 1;
  }, [selectedCharacter]);

  const drawBullets = useCallback((ctx: CanvasRenderingContext2D) => {
    const bullets = bulletsRef.current;
    
    if (bullets.length > 0) {
      console.log('ğŸ¨ Drawing bullets:', bullets.length);
    }
    
    bullets.forEach(bullet => {
      ctx.save();
      
      // Enhanced bullet drawing
      if (bullet.owner === 'player') {
        // Player bullets - energy blasts
        ctx.fillStyle = bullet.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = bullet.color;
        
        // Draw energy bullet
        ctx.beginPath();
        ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, bullet.width/2, 0, Math.PI * 2);
        ctx.fill();
        
        // Add glow effect
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, bullet.width/4, 0, Math.PI * 2);
        ctx.fill();
      } else {
        // Enemy bullets - plasma shots
        ctx.fillStyle = bullet.color;
        ctx.shadowBlur = 8;
        ctx.shadowColor = bullet.color;
        
        // Draw plasma bullet
        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        
        // Add inner glow
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = 0.5;
        ctx.fillRect(bullet.x + 1, bullet.y + 1, bullet.width - 2, bullet.height - 2);
      }
      
      ctx.restore();
    });
  }, []);

  const drawEnemies = useCallback((ctx: CanvasRenderingContext2D) => {
    const enemies = enemiesRef.current;
    
    enemies.forEach(enemy => {
      ShipRenderer.drawEnemyShip(ctx, enemy.x, enemy.y, enemy.width, enemy.height, enemy.type, 0);
    });
  }, []);

  const drawBosses = useCallback((ctx: CanvasRenderingContext2D) => {
    const bosses = bossesRef.current;
    
    bosses.forEach(boss => {
      ShipRenderer.drawBossShip(ctx, boss.x, boss.y, boss.width, boss.height, boss.health, boss.maxHealth);
    });
  }, []);

  const drawPowerUps = useCallback((ctx: CanvasRenderingContext2D) => {
    const powerUps = powerUpsRef.current;
    
    powerUps.forEach(powerUp => {
      ctx.fillStyle = powerUp.color;
      ctx.shadowBlur = 5;
      ctx.shadowColor = powerUp.color;
      ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
      ctx.shadowBlur = 0;
    });
  }, []);

  const drawUI = useCallback((ctx: CanvasRenderingContext2D) => {
    const player = playerRef.current;
    const canvas = canvasRef.current;
    if (!canvas) return;

    // Score
    ctx.fillStyle = '#00aaff';
    ctx.font = '24px Arial';
    ctx.fillText(`Score: ${gameStats.score.toLocaleString()}`, 20, 40);

    // Combo display
    const currentCombo = comboSystemRef.current.getCurrentCombo();
    const comboMultiplier = comboSystemRef.current.getComboMultiplier();
    if (currentCombo > 0) {
      ctx.fillStyle = '#ff6600';
      ctx.font = '20px Arial';
      ctx.fillText(`Combo: ${currentCombo}x${comboMultiplier}`, 20, 70);
    }

    // Health bar
    const healthBarWidth = 200;
    const healthBarHeight = 20;
    const healthPercentage = player.health / player.maxHealth;
    
    ctx.fillStyle = '#333333';
    ctx.fillRect(20, canvas.height - 40, healthBarWidth, healthBarHeight);
    
    ctx.fillStyle = healthPercentage > 0.5 ? '#00ff00' : healthPercentage > 0.25 ? '#ffff00' : '#ff0000';
    ctx.fillRect(20, canvas.height - 40, healthBarWidth * healthPercentage, healthBarHeight);
    
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px Arial';
    ctx.fillText(`Health: ${player.health}/${player.maxHealth}`, 20, canvas.height - 45);
  }, [gameStats.score]);

  const shoot = useCallback(() => {
    if (gameState !== 'playing') return;

    const player = playerRef.current;
    const bullets = bulletsRef.current;

    // Player bullet
    bullets.push({
      x: player.x + player.width / 2 - 2,
      y: player.y,
      width: 4,
      height: 10,
      speed: 8,
      type: 'energy',
      color: '#00aaff',
      damage: 1,
      owner: 'player'
    });

    // Debug logging
    console.log('ğŸš€ Player shot! Bullets count:', bullets.length);

    // Update weapons used stat
    setGameStats(prevStats => ({
      ...prevStats,
      weaponsUsed: prevStats.weaponsUsed + 1
    }));
  }, [gameState]);

  return (
    <div className="game-container">
      <canvas 
        ref={canvasRef}
        className="game-canvas"
        width={800}
        height={600}
      />
      
      {gameState === 'menu' && (
        <div className="main-menu-container">
          {/* Animated Background */}
          <div className="menu-background">
            <div className="stars"></div>
            <div className="nebula"></div>
          </div>
          
          {/* Main Menu Content */}
          <div className="menu-content">
            {/* Game Title with Scrolling Animation */}
            <div className="title-container">
              <h1 className="game-title">
                <span className="title-text">ğŸš€ Kaden & Adelynn Space Adventures</span>
              </h1>
              <p className="game-subtitle">Epic Space Shooter Adventure</p>
              <p style={{color: 'white', fontSize: '14px', marginTop: '10px'}}>Debug: Menu is rendering, gameState: {gameState}</p>
            </div>
            
            {/* Character Display Section */}
            <div className="character-section">
              <div className="selected-character-card">
                <div className="character-sprite-container">
                  <canvas 
                    ref={(canvas) => {
                      if (canvas) {
                        const ctx = canvas.getContext('2d');
                        canvas.width = 120;
                        canvas.height = 120;
                        
                        // Clear canvas
                        ctx.clearRect(0, 0, 120, 120);
                        
                        // Draw character
                        if (selectedCharacter === 'kaden') {
                          const kadenRenderer = new KadenSpriteRenderer();
                          kadenRenderer.renderKaden(ctx, 60, 60, 'idle', Date.now());
                        } else if (selectedCharacter === 'adelynn') {
                          const adelynnRenderer = new AdelynnSpriteRenderer();
                          adelynnRenderer.renderAdelynn(ctx, 60, 60, 'idle', Date.now());
                        }
                      }
                    }}
                    width="120" 
                    height="120"
                    className="character-sprite"
                  />
                </div>
                <div className="character-info">
                  <h3 className="character-name">
                    {Storyline.characters[selectedCharacter as keyof typeof Storyline.characters]?.name}
                  </h3>
                  <p className="character-ship">
                    {Storyline.characters[selectedCharacter as keyof typeof Storyline.characters]?.ship}
                  </p>
                </div>
              </div>
            </div>
            
            {/* Menu Buttons */}
            <div className="menu-buttons-container">
              <button className="menu-button primary" onClick={startGame}>
                <span className="button-icon">ğŸ®</span>
                <span className="button-text">Start Game</span>
              </button>
              
              <button className="menu-button secondary" onClick={() => setShowCharacterSelection(true)}>
                <span className="button-icon">ğŸ‘¥</span>
                <span className="button-text">Choose Character</span>
              </button>
              
              <button className="menu-button secondary" onClick={() => setShowSettings(true)}>
                <span className="button-icon">âš™ï¸</span>
                <span className="button-text">Settings</span>
              </button>
            </div>
            
            {/* Game Information */}
            <div className="game-info-section">
              <div className="info-grid">
                <div className="info-item">
                  <span className="info-icon">ğŸ¯</span>
                  <span className="info-text">Defend the galaxy from alien invaders!</span>
                </div>
                <div className="info-item">
                  <span className="info-icon">ğŸš€</span>
                  <span className="info-text">Power-ups, Boss Battles, Achievements & More!</span>
                </div>
                <div className="info-item">
                  <span className="info-icon">ğŸ®</span>
                  <span className="info-text">Arrow Keys / WASD to move, S to shoot</span>
                </div>
                <div className="info-item">
                  <span className="info-icon">ğŸ“±</span>
                  <span className="info-text">Touch controls with haptic feedback</span>
                </div>
              </div>
            </div>
            
            {/* Company Branding */}
            <div className="company-branding">
              <p>Â© 2025 Bradley Virtual Solutions, LLC</p>
            </div>
          </div>
        </div>
      )}
      
      {gameState === 'gameOver' && (
        <div className="game-over-overlay">
          <h2 className="game-over-title">ğŸ’¥ Game Over!</h2>
          <div className="game-over-stats">
            <p><strong>ğŸ† Final Score:</strong> {gameStats.score.toLocaleString()}</p>
            <p><strong>â­ High Score:</strong> {gameStats.highScore.toLocaleString()}</p>
            <p><strong>ğŸ‘¾ Enemies Destroyed:</strong> {gameStats.enemiesDestroyed}</p>
            <p><strong>ğŸ‘¹ Bosses Defeated:</strong> {gameStats.bossesDefeated}</p>
            <p><strong>ğŸ”¥ Max Combo:</strong> {gameStats.maxCombo}</p>
            <p><strong>âš”ï¸ Max Kill Streak:</strong> {gameStats.maxKillStreak}</p>
            <p><strong>â° Survival Time:</strong> {Math.floor(gameStats.gameTime / 1000)}s</p>
          </div>
          <div className="game-over-buttons">
            <button className="menu-button" onClick={startGame}>
              ğŸ”„ Play Again
            </button>
            <button className="menu-button" onClick={() => setGameState('menu')}>
              ğŸ  Main Menu
            </button>
          </div>
          <p className="company-branding"><strong>Â© 2025 Bradley Virtual Solutions, LLC</strong></p>
        </div>
      )}
      
      {gameState === 'playing' && mobileSystemRef.current.hasTouchSupport() && (
        <div className="touch-controls">
          <button 
            className="touch-shoot-button"
            onTouchStart={(e) => {
              e.preventDefault();
              shoot();
              mobileSystemRef.current.lightVibrate();
            }}
          >
            ğŸ”« SHOOT
          </button>
        </div>
      )}

      {/* Settings Panel */}
      <SettingsPanel 
        isOpen={showSettings}
        onClose={() => setShowSettings(false)}
        onSettingsChange={() => {}}
      />

      {/* Character Selection */}
      <CharacterSelection 
        isOpen={showCharacterSelection}
        onClose={() => setShowCharacterSelection(false)}
        onCharacterSelect={setSelectedCharacter}
      />

      {/* Story Event Display */}
      {currentStoryEvent && (
        <div className="story-event-display">
          <div className="story-event-content">
            <h3>ğŸ“– Story Event</h3>
            <p>{currentStoryEvent}</p>
            <button onClick={() => setCurrentStoryEvent('')}>Continue</button>
          </div>
        </div>
      )}
      
      {/* PWA Install Prompt */}
      <PWAInstallPrompt />
    </div>
  );
};

export default Game;